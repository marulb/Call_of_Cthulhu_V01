{
  "name": "DungeonMaster Main",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "coc_dungeonmaster",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "dm-webhook-001",
      "name": "Webhook - DungeonMaster",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        -1200,
        400
      ],
      "webhookId": "coc-dungeonmaster-webhook"
    },
    {
      "parameters": {
        "jsCode": "// Parse incoming player actions\nconst body = $json.body || $json;\nconst activeTurn = body.ActiveTurn || [];\nconst sceneId = body.scene_id || null;\nconst sessionId = body.session_id || null;\nconst campaignId = body.campaign_id || null;\nconst turnId = body.turn_id || null;\n\nif (!activeTurn || activeTurn.length === 0) {\n  throw new Error('No player actions provided in ActiveTurn');\n}\n\nif (!sceneId || !sessionId || !campaignId) {\n  throw new Error('Missing required context: scene_id, session_id, campaign_id');\n}\n\n// Extract character IDs from actions\nconst characterIds = activeTurn\n  .map(action => action.character_id)\n  .filter(id => id);\n\nreturn [\n  {\n    json: {\n      player_actions: activeTurn,\n      scene_id: sceneId,\n      session_id: sessionId,\n      campaign_id: campaignId,\n      turn_id: turnId,\n      character_ids: characterIds,\n      iteration_count: 0,\n      max_iterations: 5,\n      collected_data: {\n        player_actions: activeTurn\n      },\n      references: [],\n      skill_checks: []\n    }\n  }\n];"
      },
      "id": "dm-parse-001",
      "name": "Parse Actions",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1008,
        400
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://host.docker.internal:11434/api/chat",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  model: 'gpt-oss:20b',\n  messages: [\n    {\n      role: 'system',\n      content: `You are a skill check detector for Call of Cthulhu 7th Edition. Analyze player actions and identify which skill checks are required.\n\nCommon triggers:\n- \"examine\", \"inspect\", \"search\" → Spot Hidden\n- \"listen\", \"hear\" → Listen\n- \"convince\", \"persuade\" → Persuade\n- \"sneak\", \"hide\" → Stealth\n- \"library\", \"research\", \"study\" → Library Use\n- \"recall\", \"remember\", \"know\" → relevant knowledge skill\n- \"climb\" → Climb\n- \"jump\" → Jump\n- \"shoot\", \"fire\" → Firearms\n- \"punch\", \"hit\" → Fighting (Brawl)\n\nRespond in JSON format:\n{\n  \"skill_checks\": [\n    {\n      \"character_id\": \"char-id\",\n      \"character_name\": \"Name\",\n      \"skill_name\": \"Spot Hidden\",\n      \"difficulty\": \"Regular|Hard|Extreme\",\n      \"reason\": \"Player is examining the door\"\n    }\n  ]\n}\n\nIf no skill checks needed, return: {\"skill_checks\": []}`\n    },\n    {\n      role: 'user',\n      content: `Player Actions:\\n${JSON.stringify($json.player_actions, null, 2)}`\n    }\n  ],\n  stream: false,\n  options: {\n    temperature: 0.3,\n    num_predict: 500\n  }\n}) }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "dm-skilldetect-001",
      "name": "Detect Skill Checks",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -816,
        400
      ]
    },
    {
      "parameters": {
        "jsCode": "// Parse skill checks from LLM response\nconst ollamaResponse = $json.message?.content || $json.response || '{}';\nlet detectedChecks = [];\n\ntry {\n  const parsed = JSON.parse(ollamaResponse);\n  detectedChecks = parsed.skill_checks || [];\n} catch (e) {\n  console.error('Failed to parse skill check detection:', e);\n  detectedChecks = [];\n}\n\n// Carry forward context\nconst previousData = $input.first().json;\n\nreturn [\n  {\n    json: {\n      ...previousData,\n      detected_skill_checks: detectedChecks,\n      has_skill_checks: detectedChecks.length > 0\n    }\n  }\n];"
      },
      "id": "dm-parseskills-001",
      "name": "Parse Detected Skills",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -624,
        400
      ]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true
          },
          "conditions": [
            {
              "leftValue": "={{ $json.has_skill_checks }}",
              "rightValue": "true",
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ]
        }
      },
      "id": "dm-ifskills-001",
      "name": "Has Skill Checks?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -432,
        400
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare MongoDB query to fetch character data for skill checks\nconst characterIds = $json.character_ids || [];\n\nreturn [\n  {\n    json: {\n      query_type: 'character',\n      filters: characterIds.length > 0 ? { id: { $in: characterIds } } : {}\n    }\n  }\n];"
      },
      "id": "dm-prepchar-001",
      "name": "Prepare Character Fetch",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -240,
        304
      ]
    },
    {
      "parameters": {
        "workflowId": "={{ 'y55TmujQLP0CCW1G' }}",
        "options": {}
      },
      "id": "dm-mongochar-001",
      "name": "Fetch Characters",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.1,
      "position": [
        -48,
        304
      ]
    },
    {
      "parameters": {
        "jsCode": "// Match detected skill checks with character data and prepare dice rolls\nconst detectedChecks = $input.first().json.detected_skill_checks || [];\nconst characterData = $json.data || [];\nconst skillCheckResults = [];\n\n// Build character lookup map\nconst charMap = {};\nfor (const char of characterData) {\n  charMap[char.id] = char;\n}\n\n// Process each detected skill check\nfor (const check of detectedChecks) {\n  const character = charMap[check.character_id];\n  \n  if (!character) {\n    console.warn(`Character ${check.character_id} not found`);\n    continue;\n  }\n\n  // Find skill value\n  const skillName = check.skill_name;\n  const skills = character.skills || [];\n  const skill = skills.find(s => \n    s.name.toLowerCase() === skillName.toLowerCase()\n  );\n\n  if (!skill) {\n    console.warn(`Skill ${skillName} not found for ${character.name}`);\n    continue;\n  }\n\n  // Prepare dice roll\n  skillCheckResults.push({\n    roll_type: 'skill_check',\n    skill_name: skillName,\n    skill_value: skill.value || skill.base || 0,\n    character_id: check.character_id,\n    character_name: character.name,\n    difficulty: check.difficulty || 'Regular',\n    bonus_dice: 0,\n    penalty_dice: 0,\n    reason: check.reason\n  });\n}\n\nreturn skillCheckResults.map(check => ({ json: check }));"
      },
      "id": "dm-matchskills-001",
      "name": "Match Skills to Characters",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        144,
        304
      ]
    },
    {
      "parameters": {
        "workflowId": "={{ '6XlcM8xBgOmhxIpM' }}",
        "options": {}
      },
      "id": "dm-rollskills-001",
      "name": "Roll Skill Checks",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.1,
      "position": [
        336,
        304
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare campaign query\nconst campaignId = $input.first().json.campaign_id;\n\nreturn [\n  {\n    json: {\n      query_type: 'campaign',\n      filters: { id: campaignId }\n    }\n  }\n];"
      },
      "id": "dm-prepcampaign-001",
      "name": "Prepare Campaign Fetch",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -240,
        496
      ]
    },
    {
      "parameters": {
        "workflowId": "={{ 'y55TmujQLP0CCW1G' }}",
        "options": {}
      },
      "id": "dm-mongocampaign-001",
      "name": "Fetch Campaign",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.1,
      "position": [
        -48,
        496
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare scene query\nconst sceneId = $input.first().json.scene_id;\n\nreturn [\n  {\n    json: {\n      query_type: 'scene',\n      filters: { id: sceneId }\n    }\n  }\n];"
      },
      "id": "dm-prepscene-001",
      "name": "Prepare Scene Fetch",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        144,
        496
      ]
    },
    {
      "parameters": {
        "workflowId": "={{ 'y55TmujQLP0CCW1G' }}",
        "options": {}
      },
      "id": "dm-mongoscene-001",
      "name": "Fetch Scene",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.1,
      "position": [
        336,
        496
      ]
    },
    {
      "parameters": {
        "jsCode": "// Build context query for Qdrant based on player actions\nconst playerActions = $input.first().json.player_actions || [];\n\n// Extract all text from actions\nconst actionTexts = [];\nfor (const action of playerActions) {\n  if (action.speak) actionTexts.push(action.speak);\n  if (action.act) actionTexts.push(action.act);\n  if (action.ooc) actionTexts.push(action.ooc);\n}\n\nconst combinedText = actionTexts.join(' ');\n\nreturn [\n  {\n    json: {\n      query: combinedText,\n      collection: 'Cthulhu_Wiki',\n      limit: 3\n    }\n  }\n];"
      },
      "id": "dm-prepqdrant-001",
      "name": "Prepare Lore Query",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        528,
        496
      ]
    },
    {
      "parameters": {
        "workflowId": "={{ 'RujcKBHIYtoxE5H4' }}",
        "options": {}
      },
      "id": "dm-qdrant-001",
      "name": "Fetch Lore",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.1,
      "position": [
        720,
        496
      ]
    },
    {
      "parameters": {
        "jsCode": "// Merge all collected data\nconst allItems = $input.all();\nconst firstItem = $input.first().json;\n\nlet collectedData = firstItem.collected_data || {};\nlet references = firstItem.references || [];\nlet skillChecks = [];\n\n// Merge data from all sources\nfor (const item of allItems) {\n  const data = item.json.data;\n  const refs = item.json.references || [];\n  const queryType = item.json.query_type;\n\n  // MongoDB results\n  if (data && queryType) {\n    if (queryType === 'character') {\n      collectedData.characters = data;\n    } else if (queryType === 'campaign') {\n      collectedData.campaign = data[0] || null;\n    } else if (queryType === 'scene') {\n      collectedData.scene = data[0] || null;\n    }\n  }\n\n  // Qdrant chunks\n  if (item.json.chunks) {\n    collectedData.rules_chunks = collectedData.rules_chunks || [];\n    collectedData.rules_chunks.push(...item.json.chunks);\n  }\n\n  // Skill check results\n  if (item.json.roll_type === 'skill_check') {\n    skillChecks.push({\n      character_id: item.json.character_id,\n      character_name: item.json.character_name,\n      skill_name: item.json.skill_name,\n      skill_value: item.json.skill_value,\n      rolled: item.json.rolled,\n      target_value: item.json.target_value,\n      success_level: item.json.success_level,\n      success: item.json.success,\n      formatted: item.json.formatted\n    });\n  }\n\n  // Merge references\n  references.push(...refs);\n}\n\n// Deduplicate references\nreferences = [...new Set(references)];\n\ncollectedData.skill_checks = skillChecks;\n\nreturn [\n  {\n    json: {\n      ...firstItem,\n      collected_data: collectedData,\n      references: references,\n      skill_checks: skillChecks\n    }\n  }\n];"
      },
      "id": "dm-merge-001",
      "name": "Merge Collected Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        912,
        400
      ]
    },
    {
      "parameters": {
        "jsCode": "// Prepare LLM Synthesizer input\nconst collectedData = $json.collected_data || {};\nconst references = $json.references || [];\n\nreturn [\n  {\n    json: {\n      agent_type: 'dungeonmaster',\n      collected_data: collectedData,\n      references: references\n    }\n  }\n];"
      },
      "id": "dm-prepllm-001",
      "name": "Prepare LLM Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1104,
        400
      ]
    },
    {
      "parameters": {
        "workflowId": "={{ 'l0qIOBJbnkSQagfu' }}",
        "options": {}
      },
      "id": "dm-llm-001",
      "name": "Generate Scene Narrative",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.1,
      "position": [
        1296,
        400
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://host.docker.internal:11434/api/chat",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  model: 'gpt-oss:20b',\n  messages: [\n    {\n      role: 'system',\n      content: `You are an interaction detector for Call of Cthulhu. Analyze the generated scene and determine if it requires user input.\n\nRequires User Input (STOP):\n- Scene presents choices to players\n- Players need to declare their next actions\n- Combat initiated (players must respond)\n- NPC asks direct question to players\n- Hidden passage/door found (players decide what to do)\n- Suspenseful cliffhanger requiring player decision\n\nAuto-Continue (NO_STOP):\n- Pure narration of outcomes\n- NPC monologue or exposition\n- Environment description\n- Skill check results explained\n- Automatic consequences of player actions\n\nRespond in JSON:\n{\n  \"requires_input\": true/false,\n  \"reason\": \"explanation\",\n  \"interaction_type\": \"CHOICE|COMBAT|QUESTION|DISCOVERY|CLIFFHANGER|NONE\"\n}`\n    },\n    {\n      role: 'user',\n      content: `Generated Scene:\\n${$json.answer}`\n    }\n  ],\n  stream: false,\n  options: {\n    temperature: 0.2,\n    num_predict: 200\n  }\n}) }}",
        "options": {
          "timeout": 30000
        }
      },
      "id": "dm-interact-001",
      "name": "Detect Interaction Needed",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1488,
        400
      ]
    },
    {
      "parameters": {
        "jsCode": "// Parse interaction detection\nconst ollamaResponse = $json.message?.content || $json.response || '{}';\nlet interactionData = {\n  requires_input: false,\n  reason: 'Unknown',\n  interaction_type: 'NONE'\n};\n\ntry {\n  const parsed = JSON.parse(ollamaResponse);\n  interactionData = parsed;\n} catch (e) {\n  console.error('Failed to parse interaction detection:', e);\n}\n\n// Carry forward all context\nconst previousData = $input.first().json;\nconst sceneAnswer = previousData.answer;\n\nreturn [\n  {\n    json: {\n      ...previousData,\n      interaction: interactionData,\n      scene_narrative: sceneAnswer\n    }\n  }\n];"
      },
      "id": "dm-parseinteract-001",
      "name": "Parse Interaction",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1680,
        400
      ]
    },
    {
      "parameters": {
        "operation": "update",
        "collection": "turns",
        "updateKey": "id",
        "fieldsUi": {
          "field": [
            {
              "fieldName": "reaction",
              "fieldValue": "={{ JSON.stringify({\n  description: $json.scene_narrative,\n  timestamp: new Date().toISOString(),\n  skill_checks: $json.skill_checks || [],\n  requires_input: $json.interaction?.requires_input || false,\n  interaction_type: $json.interaction?.interaction_type || 'NONE'\n}) }}"
            },
            {
              "fieldName": "status",
              "fieldValue": "={{ $json.interaction?.requires_input ? 'awaiting_player_input' : 'completed' }}"
            }
          ]
        },
        "options": {}
      },
      "id": "dm-writeturn-001",
      "name": "Write Turn Reaction",
      "type": "n8n-nodes-base.mongoDb",
      "typeVersion": 1.2,
      "position": [
        1872,
        400
      ],
      "credentials": {
        "mongoDb": {
          "id": "KatUu4hcJi0VoYNT",
          "name": "MongoDB account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Format final response\nconst sceneNarrative = $json.scene_narrative || '';\nconst skillChecks = $json.skill_checks || [];\nconst requiresInput = $json.interaction?.requires_input || false;\nconst interactionType = $json.interaction?.interaction_type || 'NONE';\n\n// Build rules_applied array\nconst rulesApplied = [];\n\nfor (const check of skillChecks) {\n  rulesApplied.push({\n    rule_type: 'skill_check',\n    skill_name: check.skill_name,\n    character_name: check.character_name,\n    result: check.success_level,\n    details: check.formatted\n  });\n}\n\nreturn [\n  {\n    json: {\n      output: sceneNarrative,\n      rules_applied: rulesApplied,\n      requires_input: requiresInput,\n      interaction_type: interactionType\n    }\n  }\n];"
      },
      "id": "dm-format-001",
      "name": "Format Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2064,
        400
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ JSON.stringify($json) }}",
        "options": {
          "responseCode": 200,
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "id": "dm-respond-001",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [
        2256,
        400
      ]
    },
    {
      "parameters": {
        "jsCode": "// No skill checks path - skip directly to campaign/scene fetch\nreturn [$json];"
      },
      "id": "dm-noskills-001",
      "name": "No Skill Checks Path",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -240,
        592
      ]
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook - DungeonMaster": {
      "main": [
        [
          {
            "node": "Parse Actions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Actions": {
      "main": [
        [
          {
            "node": "Detect Skill Checks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Detect Skill Checks": {
      "main": [
        [
          {
            "node": "Parse Detected Skills",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Detected Skills": {
      "main": [
        [
          {
            "node": "Has Skill Checks?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Skill Checks?": {
      "main": [
        [
          {
            "node": "Prepare Character Fetch",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Skill Checks Path",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Character Fetch": {
      "main": [
        [
          {
            "node": "Fetch Characters",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Characters": {
      "main": [
        [
          {
            "node": "Match Skills to Characters",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Match Skills to Characters": {
      "main": [
        [
          {
            "node": "Roll Skill Checks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Roll Skill Checks": {
      "main": [
        [
          {
            "node": "Merge Collected Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No Skill Checks Path": {
      "main": [
        [
          {
            "node": "Prepare Campaign Fetch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Campaign Fetch": {
      "main": [
        [
          {
            "node": "Fetch Campaign",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Campaign": {
      "main": [
        [
          {
            "node": "Prepare Scene Fetch",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Scene Fetch": {
      "main": [
        [
          {
            "node": "Fetch Scene",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Scene": {
      "main": [
        [
          {
            "node": "Prepare Lore Query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Lore Query": {
      "main": [
        [
          {
            "node": "Fetch Lore",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Lore": {
      "main": [
        [
          {
            "node": "Merge Collected Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Collected Data": {
      "main": [
        [
          {
            "node": "Prepare LLM Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare LLM Input": {
      "main": [
        [
          {
            "node": "Generate Scene Narrative",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Scene Narrative": {
      "main": [
        [
          {
            "node": "Detect Interaction Needed",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Detect Interaction Needed": {
      "main": [
        [
          {
            "node": "Parse Interaction",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Interaction": {
      "main": [
        [
          {
            "node": "Write Turn Reaction",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Write Turn Reaction": {
      "main": [
        [
          {
            "node": "Format Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Response": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "dungeonmaster-main-v1",
  "meta": {
    "instanceId": "00a8bc7dcc0678a45156c17552244c5fb9e78ff325baae937e09d98a3453ca71"
  },
  "id": "DungeonMasterMainWorkflow",
  "tags": []
}
