{
  "name": "LLM Synthesizer SubWF",
  "nodes": [
    {
      "parameters": {},
      "id": "8a5b62e2-472f-4cd9-a1e7-c13cd4502135",
      "name": "Execute Workflow Trigger",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1,
      "position": [
        128,
        -272
      ]
    },
    {
      "parameters": {
        "jsCode": "// Build context prompt for LLM\nconst question = $json.question || $json.query || '';\nconst collectedData = $json.collected_data || {};\nconst agentType = $json.agent_type || 'prophet';\nconst references = $json.references || [];\n\n// Build system prompt based on agent type\nlet systemPrompt = '';\n\nif (agentType === 'prophet') {\n  systemPrompt = `You are the Prophet, a helpful assistant for Call of Cthulhu RPG players. Your role is to answer questions about:\n- Character statistics and abilities\n- Game rules and mechanics\n- Turn history and past events\n- Dice rolling and skill checks\n- Campaign lore and story elements\n\nIMPORTANT GUIDELINES:\n- Be concise and factual\n- Cite sources when available\n- If data is missing or unclear, acknowledge it\n- Use Call of Cthulhu terminology accurately\n- Maintain the dark, mysterious tone of the setting`;\n\n} else if (agentType === 'dungeonmaster') {\n  systemPrompt = `You are the DungeonMaster agent for Call of Cthulhu. Your role:\n1. Process player-declared actions\n2. Resolve skill checks\n3. Generate narrative reactions (NPCs, environment, outcomes)\n4. Detect scene/chapter transitions\n\nCRITICAL RULES:\n- NEVER decide what player characters do\n- ONLY describe outcomes of player-declared actions\n- If the scene requires player decisions, STOP and return the scene\n- NPCs and environment can act autonomously\n- Players control their characters exclusively\n\nYour narrative should:\n- Drive toward campaign milestones\n- Incorporate Call of Cthulhu mythos and tone\n- Reflect skill check outcomes\n- Maintain dark, atmospheric tension\n\nTRANSITION DETECTION:\nDetermine if a scene or chapter transition is needed:\n\nNEW SCENE triggers:\n- Location change within same building/area (basement to first floor)\n- Time skip less than 1 day (several hours later)\n- Dramatic event that shifts focus (combat ends, ritual completed)\n- Discovery of significant location (hidden room, portal)\n\nNEW CHAPTER triggers:\n- Major location change (different building, different city)\n- Time skip greater than 1 day (three days later, next week)\n- Story milestone (defeat major enemy, complete investigation)\n- Tone shift (investigation to combat arc, city to wilderness)\n\nNO TRANSITION:\n- Continuing in same location and timeframe\n- Dialogue or interaction in progress\n- Combat in same scene\n\nRESPOND WITH VALID JSON ONLY containing these fields:\n- narrative: Your full narrative response in 2-4 paragraphs\n- summary: One sentence summary of what happened\n- transition object with: type (scene/chapter/none), reason (string or null), suggested_name (string or null), suggested_description (string or null)\n- requires_input: boolean true or false\n- interaction_type: one of CHOICE, COMBAT, QUESTION, DISCOVERY, or NONE`;\n}\n\n// Build user prompt with collected data\nlet userPromptParts = [];\n\n// Always start with the original question\nif (question) {\n  userPromptParts.push(`Question: ${question}`);\n  userPromptParts.push('');\n}\n\n// Handle dice roll results from collected_data\nif (collectedData.dice_result) {\n  userPromptParts.push('=== DICE ROLL RESULT ===');\n  if (collectedData.dice_result.formatted) {\n    userPromptParts.push(collectedData.dice_result.formatted);\n  } else {\n    userPromptParts.push(`Expression: ${collectedData.dice_result.expression || 'unknown'}`);\n    userPromptParts.push(`Total: ${collectedData.dice_result.total}`);\n  }\n  userPromptParts.push('');\n}\n\n// Add character data\nif (collectedData.characters && collectedData.characters.length > 0) {\n  userPromptParts.push('=== CHARACTER DATA ===');\n  collectedData.characters.forEach(char => {\n    userPromptParts.push(`Character: ${char.name}`);\n    if (char.occupation) userPromptParts.push(`Occupation: ${char.occupation}`);\n    if (char.sanity) userPromptParts.push(`Sanity: ${char.sanity.current}/${char.sanity.max}`);\n    if (char.hit_points) userPromptParts.push(`HP: ${char.hit_points.current}/${char.hit_points.max}`);\n    userPromptParts.push('');\n  });\n}\n\n// Add campaign data\nif (collectedData.campaign) {\n  const campaign = collectedData.campaign;\n  userPromptParts.push('=== CAMPAIGN CONTEXT ===');\n  if (campaign.name) userPromptParts.push(`Campaign: ${campaign.name}`);\n  if (campaign.setting?.tone) userPromptParts.push(`Tone: ${campaign.setting.tone}`);\n  if (campaign.setting?.goal) userPromptParts.push(`Goal: ${campaign.setting.goal}`);\n  if (campaign.story_arc?.tagline) userPromptParts.push(`Story: ${campaign.story_arc.tagline}`);\n  if (campaign.setting?.key_elements) {\n    userPromptParts.push(`Key Elements: ${campaign.setting.key_elements.join(', ')}`);\n  }\n  userPromptParts.push('');\n}\n\n// Add rules/lore chunks from Qdrant\nif (collectedData.rules_chunks && collectedData.rules_chunks.length > 0) {\n  userPromptParts.push('=== RELEVANT RULES ===');\n  collectedData.rules_chunks.forEach((chunk, idx) => {\n    userPromptParts.push(`[${idx + 1}] ${chunk.text}`);\n    userPromptParts.push(`Source: ${chunk.source}`);\n    userPromptParts.push('');\n  });\n}\n\n// Add turn history\nif (collectedData.turns && collectedData.turns.length > 0) {\n  userPromptParts.push('=== TURN HISTORY ===');\n  collectedData.turns.forEach(turn => {\n    userPromptParts.push(`Turn #${turn.turn_number}:`);\n    if (turn.actions) {\n      turn.actions.forEach(action => {\n        if (action.speak) userPromptParts.push(`  Speak: ${action.speak}`);\n        if (action.act) userPromptParts.push(`  Act: ${action.act}`);\n      });\n    }\n    if (turn.reaction?.description) {\n      userPromptParts.push(`  Reaction: ${turn.reaction.description}`);\n    }\n    userPromptParts.push('');\n  });\n}\n\n// Add player actions (for DungeonMaster)\nif (collectedData.player_actions && collectedData.player_actions.length > 0) {\n  userPromptParts.push('=== PLAYER ACTIONS ===');\n  collectedData.player_actions.forEach((action, idx) => {\n    userPromptParts.push(`[${idx + 1}] ${action.character_name || 'Character'}:`);\n    if (action.speak) userPromptParts.push(`  Says: \"${action.speak}\"`);\n    if (action.act) userPromptParts.push(`  Does: ${action.act}`);\n    if (action.appearance) userPromptParts.push(`  Appearance: ${action.appearance}`);\n    if (action.emotion) userPromptParts.push(`  Emotion: ${action.emotion}`);\n    userPromptParts.push('');\n  });\n}\n\n// Add skill check results (for DungeonMaster)\nif (collectedData.skill_checks && collectedData.skill_checks.length > 0) {\n  userPromptParts.push('=== SKILL CHECK RESULTS ===');\n  collectedData.skill_checks.forEach(check => {\n    userPromptParts.push(`${check.character_name || 'Character'}: ${check.skill_name} - ${check.success_level} (rolled ${check.rolled} vs ${check.target_value})`);\n  });\n  userPromptParts.push('');\n}\n\nconst userPrompt = userPromptParts.join('\\n');\n\nreturn [\n  {\n    json: {\n      system_prompt: systemPrompt,\n      user_prompt: userPrompt,\n      question,\n      references,\n      agent_type: agentType\n    }\n  }\n];"
      },
      "id": "af747f93-727e-4a74-b9f0-e4a10700f25a",
      "name": "Build Context Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        336,
        -272
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://host.docker.internal:11434/api/chat",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ model: 'gpt-oss:20b', messages: [{ role: 'system', content: $json.system_prompt }, { role: 'user', content: $json.user_prompt }], stream: false, format: 'json', options: { temperature: 0.3, num_predict: 1000 } }) }}",
        "options": {
          "timeout": 120000
        }
      },
      "id": "432d6d9d-9de9-4229-a833-22aac0f55990",
      "name": "LLM Call (Ollama)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        528,
        -272
      ]
    },
    {
      "parameters": {
        "jsCode": "// Extract answer from Ollama response\nconst ollamaResponse = $json.message?.content || $json.response || '';\n\n// Get references and agentType from Build Context Prompt node\nconst buildContextData = $('Build Context Prompt').first().json;\nconst references = buildContextData.references || [];\nconst agentType = buildContextData.agent_type || 'prophet';\n\nconsole.log('[Extract Answer] Agent type:', agentType);\nconsole.log('[Extract Answer] Raw LLM response length:', ollamaResponse.length);\n\n// For dungeonmaster agent, parse structured JSON output\nif (agentType === 'dungeonmaster') {\n  try {\n    // Try to parse the LLM response as JSON\n    const parsed = JSON.parse(ollamaResponse);\n    console.log('[Extract Answer] Parsed JSON successfully');\n    \n    // Validate required fields\n    if (parsed.narrative && parsed.transition) {\n      return [\n        {\n          json: {\n            narrative: parsed.narrative,\n            summary: parsed.summary || '',\n            transition: {\n              type: parsed.transition.type || 'none',\n              reason: parsed.transition.reason || null,\n              suggested_name: parsed.transition.suggested_name || null,\n              suggested_description: parsed.transition.suggested_description || null\n            },\n            requires_input: parsed.requires_input || false,\n            interaction_type: parsed.interaction_type || 'NONE',\n            agent_type: agentType,\n            references: references\n          }\n        }\n      ];\n    }\n  } catch (error) {\n    // If JSON parsing fails, log error and fall back to narrative-only\n    console.error('Failed to parse dungeonmaster JSON response:', error.message);\n    console.error('Raw response:', ollamaResponse);\n    \n    // Fallback: return response as narrative with no transition\n    return [\n      {\n        json: {\n          narrative: ollamaResponse,\n          summary: '',\n          transition: {\n            type: 'none',\n            reason: 'JSON parsing failed',\n            suggested_name: null,\n            suggested_description: null\n          },\n          requires_input: false,\n          interaction_type: 'NONE',\n          agent_type: agentType,\n          references: references,\n          _error: 'Failed to parse structured response'\n        }\n      }\n    ];\n  }\n}\n\n// For prophet agent, return simple answer format\nreturn [\n  {\n    json: {\n      answer: ollamaResponse,\n      references: references,\n      agent_type: agentType\n    }\n  }\n];"
      },
      "id": "21b5d399-dff3-4d02-b7e8-d7b4e115ed04",
      "name": "Extract Answer",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        736,
        -272
      ]
    }
  ],
  "connections": {
    "Execute Workflow Trigger": {
      "main": [
        [
          {
            "node": "Build Context Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Context Prompt": {
      "main": [
        [
          {
            "node": "LLM Call (Ollama)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "LLM Call (Ollama)": {
      "main": [
        [
          {
            "node": "Extract Answer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "tags": []
}